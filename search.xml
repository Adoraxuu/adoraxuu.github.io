<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript：究竟什麼是Event Loop</title>
      <link href="/2023/11/07/JavaScript%EF%BC%9A%E7%A9%B6%E7%AB%9F%E4%BB%80%E9%BA%BC%E6%98%AFEvent-Loop/"/>
      <url>/2023/11/07/JavaScript%EF%BC%9A%E7%A9%B6%E7%AB%9F%E4%BB%80%E9%BA%BC%E6%98%AFEvent-Loop/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript：究竟什麼是Event-Loop"><a href="#JavaScript：究竟什麼是Event-Loop" class="headerlink" title="JavaScript：究竟什麼是Event Loop"></a>JavaScript：究竟什麼是Event Loop</h1><p>JavaScript 是單執行緒又稱為單線程（Single Thread）的設計，它一次只能執行一個任務， 而「Event Loop」就是使JavaScript能夠處理多個任務的秘訣💡</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript包含了：Call Stack（呼叫堆疊）、Event Loop（事件循環）、Callback quequ(回調佇列)，以下會逐步介紹。</p><h2 id="Call-Stack呼叫堆疊"><a href="#Call-Stack呼叫堆疊" class="headerlink" title="Call Stack呼叫堆疊"></a>Call Stack呼叫堆疊</h2><h1 id="JavaScript：究竟什麼是Event-Loop-1"><a href="#JavaScript：究竟什麼是Event-Loop-1" class="headerlink" title="JavaScript：究竟什麼是Event Loop"></a>JavaScript：究竟什麼是Event Loop</h1><p>JavaScript 是單執行緒又稱為單線程（Single Thread）的設計，它一次只能執行一個任務， 而「Event Loop」就是使JavaScript能夠處理多個任務的秘訣💡</p><h2 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript包含了：Call Stack（呼叫堆疊）、Event Loop（事件循環）、Callback quequ(回調佇列)，以下會逐步介紹。</p><h2 id="Call-Stack呼叫堆疊-1"><a href="#Call-Stack呼叫堆疊-1" class="headerlink" title="Call Stack呼叫堆疊"></a>Call Stack呼叫堆疊</h2><p><img src="/images/eventLoop/callstack.png"></p><ul><li>因為JavaScript為單執行緒的設計，<strong>一次只能執行一個動作</strong>，因此等待執行的任務會被放入Call Stack。</li><li>準備執行的任務會像積木一樣，由下往上堆疊。</li><li>執行時，也像積木一樣，由上往下拿取，也稱為先進後出法（LIFO, Last in First out）</li></ul><hr><p>但如果出現像SetTimeout()、fetch()等等運行時間較長的函數，該怎麼辦呢？這個時候Web API就派上用場了！</p><hr><h2 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h2><p><img src="/images/eventLoop/webapis.png"></p><ul><li>每當呼叫非同步函數時，它都會被傳送到對應的瀏覽器API，該API會等待完成函數延遲的操作後再傳回進行處理。 </li><li>以setTimeout()為例，當Call Stack執行時，setTimeout()會被傳送到Web API，等待指定的時間完成再將該操作傳回進行處理。</li></ul><hr><p>從Web API等時間跑完後，它將操作發送到哪裡？他們被發送到<strong>事件佇列（Event queue）</strong></p><hr><h2 id="Event-queue-事件佇列"><a href="#Event-queue-事件佇列" class="headerlink" title="Event queue 事件佇列"></a>Event queue 事件佇列</h2><p><img src="/images/eventLoop/eventque.png"></p><ul><li>Event queue 裡面是待執行的任務，其中每個訊息都與一個 function 相關聯。</li><li>當堆疊中有足夠空間時，會從Event queue 事件佇列拿取一個任務進行處理，處理過程包含了呼叫相關聯的 function。只有當堆疊清空時，該佇列才算是完成處理。</li></ul><hr><p>上面分別介紹了Call Stack、Web APIs、Event queue，接下來可以將他們組起來了！組起來後可以更好地理解Event Loop。</p><hr><h2 id="Event-Loop-事件循環"><a href="#Event-Loop-事件循環" class="headerlink" title="Event Loop 事件循環"></a>Event Loop 事件循環</h2><p><img src="/images/eventLoop/eventloop.png"></p><ul><li>Event Loop 它不斷檢查Call Stack呼叫堆疊是否為空。<ul><li>如果為空：則從事件佇列Event queue中新增函式至Call Stack。 </li><li>新增函式至Call Stack的步驟，又稱為非同步回調（asynchronous ）</li><li>如果不為空：處理Call Stack內的函數。</li></ul></li></ul><h2 id="範例示意"><a href="#範例示意" class="headerlink" title="範例示意"></a>範例示意</h2><p>當然，如果僅以上介紹，無法完整了解，<br>這班準備了幾個程式碼及搭配<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>，讓讀者能夠更了解其運行步驟</p><p>:warning:可以按此<a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coIkhpIik7CnNldFRpbWVvdXQoZnVuY3Rpb24gY2IoKSB7CiAgY29uc29sZS5sb2coInRoZXJlIik7Cn0sIDUwMDApOwpjb25zb2xlLmxvZygiZW5kIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>了解JavaScript運行以上程式的步驟</p><h3 id="範例示範1"><a href="#範例示範1" class="headerlink" title="範例示範1"></a>範例示範1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;there&quot;</span>);<br>&#125;, <span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi<br><span class="hljs-keyword">end</span><br>there<br></code></pre></td></tr></table></figure><h3 id="範例示範2"><a href="#範例示範2" class="headerlink" title="範例示範2"></a>範例示範2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><p><img src="/images/eventLoop/pasted-0.png" alt="upload successful"></p><p>此又稱為<strong>堆疊爆炸</strong>，當 Stack 不斷增長，直到瀏覽器內存耗盡。<br>是瀏覽器在哀嚎的聲音😂😂</p><p>以上是關於Event Loop的介紹，是我由以下參考資料整理+自己繪圖而成，如果您有興趣了解更多，請參考：</p><h3 id="參考資料："><a href="#參考資料：" class="headerlink" title="參考資料："></a>參考資料：</h3><blockquote><p>What the heck is the event loop anyway? | Philip Roberts<br><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p><p>請說明瀏覽器中的事件循環 (Event Loop)<br><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">https://www.explainthis.io/zh-hant/swe/what-is-event-loop</a></p><p>What is an event loop in JavaScript?<br><a href="https://www.educative.io/answers/what-is-an-event-loop-in-javascript">https://www.educative.io/answers/what-is-an-event-loop-in-javascript</a></p></blockquote><ul><li>因為JavaScript為單執行緒的設計，<strong>一次只能執行一個動作</strong>，因此等待執行的任務會被放入Call Stack。</li><li>準備執行的任務會像積木一樣，由下往上堆疊。</li><li>執行時，也像積木一樣，由上往下拿取，也稱為先進後出法（LIFO, Last in First out）</li></ul><hr><p>但如果出現像SetTimeout()、fetch()等等運行時間較長的函數，該怎麼辦呢？這個時候Web API就派上用場了！</p><hr><h2 id="Web-APIs-1"><a href="#Web-APIs-1" class="headerlink" title="Web APIs"></a>Web APIs</h2><h1 id="JavaScript：究竟什麼是Event-Loop-2"><a href="#JavaScript：究竟什麼是Event-Loop-2" class="headerlink" title="JavaScript：究竟什麼是Event Loop"></a>JavaScript：究竟什麼是Event Loop</h1><p>JavaScript 是單執行緒又稱為單線程（Single Thread）的設計，它一次只能執行一個任務， 而「Event Loop」就是使JavaScript能夠處理多個任務的秘訣💡</p><h2 id="JavaScript-2"><a href="#JavaScript-2" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript包含了：Call Stack（呼叫堆疊）、Event Loop（事件循環）、Callback quequ(回調佇列)，以下會逐步介紹。</p><h2 id="Call-Stack呼叫堆疊-2"><a href="#Call-Stack呼叫堆疊-2" class="headerlink" title="Call Stack呼叫堆疊"></a>Call Stack呼叫堆疊</h2><p><img src="/images/eventLoop/callstack.png"></p><ul><li>因為JavaScript為單執行緒的設計，<strong>一次只能執行一個動作</strong>，因此等待執行的任務會被放入Call Stack。</li><li>準備執行的任務會像積木一樣，由下往上堆疊。</li><li>執行時，也像積木一樣，由上往下拿取，也稱為先進後出法（LIFO, Last in First out）</li></ul><hr><p>但如果出現像SetTimeout()、fetch()等等運行時間較長的函數，該怎麼辦呢？這個時候Web API就派上用場了！</p><hr><h2 id="Web-APIs-2"><a href="#Web-APIs-2" class="headerlink" title="Web APIs"></a>Web APIs</h2><p><img src="/images/eventLoop/webapis.png"></p><ul><li>每當呼叫非同步函數時，它都會被傳送到對應的瀏覽器API，該API會等待完成函數延遲的操作後再傳回進行處理。 </li><li>以setTimeout()為例，當Call Stack執行時，setTimeout()會被傳送到Web API，等待指定的時間完成再將該操作傳回進行處理。</li></ul><hr><p>從Web API等時間跑完後，它將操作發送到哪裡？他們被發送到<strong>事件佇列（Event queue）</strong></p><hr><h2 id="Event-queue-事件佇列-1"><a href="#Event-queue-事件佇列-1" class="headerlink" title="Event queue 事件佇列"></a>Event queue 事件佇列</h2><p><img src="/images/eventLoop/eventque.png"></p><ul><li>Event queue 裡面是待執行的任務，其中每個訊息都與一個 function 相關聯。</li><li>當堆疊中有足夠空間時，會從Event queue 事件佇列拿取一個任務進行處理，處理過程包含了呼叫相關聯的 function。只有當堆疊清空時，該佇列才算是完成處理。</li></ul><hr><p>上面分別介紹了Call Stack、Web APIs、Event queue，接下來可以將他們組起來了！組起來後可以更好地理解Event Loop。</p><hr><h2 id="Event-Loop-事件循環-1"><a href="#Event-Loop-事件循環-1" class="headerlink" title="Event Loop 事件循環"></a>Event Loop 事件循環</h2><p><img src="/images/eventLoop/eventloop.png"></p><ul><li>Event Loop 它不斷檢查Call Stack呼叫堆疊是否為空。<ul><li>如果為空：則從事件佇列Event queue中新增函式至Call Stack。 </li><li>新增函式至Call Stack的步驟，又稱為非同步回調（asynchronous ）</li><li>如果不為空：處理Call Stack內的函數。</li></ul></li></ul><h2 id="範例示意-1"><a href="#範例示意-1" class="headerlink" title="範例示意"></a>範例示意</h2><p>當然，如果僅以上介紹，無法完整了解，<br>這班準備了幾個程式碼及搭配<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>，讓讀者能夠更了解其運行步驟</p><p>:warning:可以按此<a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coIkhpIik7CnNldFRpbWVvdXQoZnVuY3Rpb24gY2IoKSB7CiAgY29uc29sZS5sb2coInRoZXJlIik7Cn0sIDUwMDApOwpjb25zb2xlLmxvZygiZW5kIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>了解JavaScript運行以上程式的步驟</p><h3 id="範例示範1-1"><a href="#範例示範1-1" class="headerlink" title="範例示範1"></a>範例示範1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;there&quot;</span>);<br>&#125;, <span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi<br><span class="hljs-keyword">end</span><br>there<br></code></pre></td></tr></table></figure><h3 id="範例示範2-1"><a href="#範例示範2-1" class="headerlink" title="範例示範2"></a>範例示範2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><p><img src="/images/eventLoop/pasted-0.png" alt="upload successful"></p><p>此又稱為<strong>堆疊爆炸</strong>，當 Stack 不斷增長，直到瀏覽器內存耗盡。<br>是瀏覽器在哀嚎的聲音😂😂</p><p>以上是關於Event Loop的介紹，是我由以下參考資料整理+自己繪圖而成，如果您有興趣了解更多，請參考：</p><h3 id="參考資料：-1"><a href="#參考資料：-1" class="headerlink" title="參考資料："></a>參考資料：</h3><blockquote><p>What the heck is the event loop anyway? | Philip Roberts<br><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p><p>請說明瀏覽器中的事件循環 (Event Loop)<br><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">https://www.explainthis.io/zh-hant/swe/what-is-event-loop</a></p><p>What is an event loop in JavaScript?<br><a href="https://www.educative.io/answers/what-is-an-event-loop-in-javascript">https://www.educative.io/answers/what-is-an-event-loop-in-javascript</a></p></blockquote><ul><li>每當呼叫非同步函數時，它都會被傳送到對應的瀏覽器API，該API會等待完成函數延遲的操作後再傳回進行處理。 </li><li>以setTimeout()為例，當Call Stack執行時，setTimeout()會被傳送到Web API，等待指定的時間完成再將該操作傳回進行處理。</li></ul><hr><p>從Web API等時間跑完後，它將操作發送到哪裡？他們被發送到<strong>事件佇列（Event queue）</strong></p><hr><h2 id="Event-queue-事件佇列-2"><a href="#Event-queue-事件佇列-2" class="headerlink" title="Event queue 事件佇列"></a>Event queue 事件佇列</h2><h1 id="JavaScript：究竟什麼是Event-Loop-3"><a href="#JavaScript：究竟什麼是Event-Loop-3" class="headerlink" title="JavaScript：究竟什麼是Event Loop"></a>JavaScript：究竟什麼是Event Loop</h1><p>JavaScript 是單執行緒又稱為單線程（Single Thread）的設計，它一次只能執行一個任務， 而「Event Loop」就是使JavaScript能夠處理多個任務的秘訣💡</p><h2 id="JavaScript-3"><a href="#JavaScript-3" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript包含了：Call Stack（呼叫堆疊）、Event Loop（事件循環）、Callback quequ(回調佇列)，以下會逐步介紹。</p><h2 id="Call-Stack呼叫堆疊-3"><a href="#Call-Stack呼叫堆疊-3" class="headerlink" title="Call Stack呼叫堆疊"></a>Call Stack呼叫堆疊</h2><p><img src="/images/eventLoop/callstack.png"></p><ul><li>因為JavaScript為單執行緒的設計，<strong>一次只能執行一個動作</strong>，因此等待執行的任務會被放入Call Stack。</li><li>準備執行的任務會像積木一樣，由下往上堆疊。</li><li>執行時，也像積木一樣，由上往下拿取，也稱為先進後出法（LIFO, Last in First out）</li></ul><hr><p>但如果出現像SetTimeout()、fetch()等等運行時間較長的函數，該怎麼辦呢？這個時候Web API就派上用場了！</p><hr><h2 id="Web-APIs-3"><a href="#Web-APIs-3" class="headerlink" title="Web APIs"></a>Web APIs</h2><p><img src="/images/eventLoop/webapis.png"></p><ul><li>每當呼叫非同步函數時，它都會被傳送到對應的瀏覽器API，該API會等待完成函數延遲的操作後再傳回進行處理。 </li><li>以setTimeout()為例，當Call Stack執行時，setTimeout()會被傳送到Web API，等待指定的時間完成再將該操作傳回進行處理。</li></ul><hr><p>從Web API等時間跑完後，它將操作發送到哪裡？他們被發送到<strong>事件佇列（Event queue）</strong></p><hr><h2 id="Event-queue-事件佇列-3"><a href="#Event-queue-事件佇列-3" class="headerlink" title="Event queue 事件佇列"></a>Event queue 事件佇列</h2><p><img src="/images/eventLoop/eventque.png"></p><ul><li>Event queue 裡面是待執行的任務，其中每個訊息都與一個 function 相關聯。</li><li>當堆疊中有足夠空間時，會從Event queue 事件佇列拿取一個任務進行處理，處理過程包含了呼叫相關聯的 function。只有當堆疊清空時，該佇列才算是完成處理。</li></ul><hr><p>上面分別介紹了Call Stack、Web APIs、Event queue，接下來可以將他們組起來了！組起來後可以更好地理解Event Loop。</p><hr><h2 id="Event-Loop-事件循環-2"><a href="#Event-Loop-事件循環-2" class="headerlink" title="Event Loop 事件循環"></a>Event Loop 事件循環</h2><p><img src="/images/eventLoop/eventloop.png"></p><ul><li>Event Loop 它不斷檢查Call Stack呼叫堆疊是否為空。<ul><li>如果為空：則從事件佇列Event queue中新增函式至Call Stack。 </li><li>新增函式至Call Stack的步驟，又稱為非同步回調（asynchronous ）</li><li>如果不為空：處理Call Stack內的函數。</li></ul></li></ul><h2 id="範例示意-2"><a href="#範例示意-2" class="headerlink" title="範例示意"></a>範例示意</h2><p>當然，如果僅以上介紹，無法完整了解，<br>這班準備了幾個程式碼及搭配<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>，讓讀者能夠更了解其運行步驟</p><p>:warning:可以按此<a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coIkhpIik7CnNldFRpbWVvdXQoZnVuY3Rpb24gY2IoKSB7CiAgY29uc29sZS5sb2coInRoZXJlIik7Cn0sIDUwMDApOwpjb25zb2xlLmxvZygiZW5kIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>了解JavaScript運行以上程式的步驟</p><h3 id="範例示範1-2"><a href="#範例示範1-2" class="headerlink" title="範例示範1"></a>範例示範1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;there&quot;</span>);<br>&#125;, <span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi<br><span class="hljs-keyword">end</span><br>there<br></code></pre></td></tr></table></figure><h3 id="範例示範2-2"><a href="#範例示範2-2" class="headerlink" title="範例示範2"></a>範例示範2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><p><img src="/images/eventLoop/pasted-0.png" alt="upload successful"></p><p>此又稱為<strong>堆疊爆炸</strong>，當 Stack 不斷增長，直到瀏覽器內存耗盡。<br>是瀏覽器在哀嚎的聲音😂😂</p><p>以上是關於Event Loop的介紹，是我由以下參考資料整理+自己繪圖而成，如果您有興趣了解更多，請參考：</p><h3 id="參考資料：-2"><a href="#參考資料：-2" class="headerlink" title="參考資料："></a>參考資料：</h3><blockquote><p>What the heck is the event loop anyway? | Philip Roberts<br><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p><p>請說明瀏覽器中的事件循環 (Event Loop)<br><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">https://www.explainthis.io/zh-hant/swe/what-is-event-loop</a></p><p>What is an event loop in JavaScript?<br><a href="https://www.educative.io/answers/what-is-an-event-loop-in-javascript">https://www.educative.io/answers/what-is-an-event-loop-in-javascript</a></p></blockquote><ul><li>Event queue 裡面是待執行的任務，其中每個訊息都與一個 function 相關聯。</li><li>當堆疊中有足夠空間時，會從Event queue 事件佇列拿取一個任務進行處理，處理過程包含了呼叫相關聯的 function。只有當堆疊清空時，該佇列才算是完成處理。</li></ul><hr><p>上面分別介紹了Call Stack、Web APIs、Event queue，接下來可以將他們組起來了！組起來後可以更好地理解Event Loop。</p><hr><h2 id="Event-Loop-事件循環-3"><a href="#Event-Loop-事件循環-3" class="headerlink" title="Event Loop 事件循環"></a>Event Loop 事件循環</h2><h1 id="JavaScript：究竟什麼是Event-Loop-4"><a href="#JavaScript：究竟什麼是Event-Loop-4" class="headerlink" title="JavaScript：究竟什麼是Event Loop"></a>JavaScript：究竟什麼是Event Loop</h1><p>JavaScript 是單執行緒又稱為單線程（Single Thread）的設計，它一次只能執行一個任務， 而「Event Loop」就是使JavaScript能夠處理多個任務的秘訣💡</p><h2 id="JavaScript-4"><a href="#JavaScript-4" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript包含了：Call Stack（呼叫堆疊）、Event Loop（事件循環）、Callback quequ(回調佇列)，以下會逐步介紹。</p><h2 id="Call-Stack呼叫堆疊-4"><a href="#Call-Stack呼叫堆疊-4" class="headerlink" title="Call Stack呼叫堆疊"></a>Call Stack呼叫堆疊</h2><p><img src="/images/eventLoop/callstack.png"></p><ul><li>因為JavaScript為單執行緒的設計，<strong>一次只能執行一個動作</strong>，因此等待執行的任務會被放入Call Stack。</li><li>準備執行的任務會像積木一樣，由下往上堆疊。</li><li>執行時，也像積木一樣，由上往下拿取，也稱為先進後出法（LIFO, Last in First out）</li></ul><hr><p>但如果出現像SetTimeout()、fetch()等等運行時間較長的函數，該怎麼辦呢？這個時候Web API就派上用場了！</p><hr><h2 id="Web-APIs-4"><a href="#Web-APIs-4" class="headerlink" title="Web APIs"></a>Web APIs</h2><p><img src="/images/eventLoop/webapis.png"></p><ul><li>每當呼叫非同步函數時，它都會被傳送到對應的瀏覽器API，該API會等待完成函數延遲的操作後再傳回進行處理。 </li><li>以setTimeout()為例，當Call Stack執行時，setTimeout()會被傳送到Web API，等待指定的時間完成再將該操作傳回進行處理。</li></ul><hr><p>從Web API等時間跑完後，它將操作發送到哪裡？他們被發送到<strong>事件佇列（Event queue）</strong></p><hr><h2 id="Event-queue-事件佇列-4"><a href="#Event-queue-事件佇列-4" class="headerlink" title="Event queue 事件佇列"></a>Event queue 事件佇列</h2><p><img src="/images/eventLoop/eventque.png"></p><ul><li>Event queue 裡面是待執行的任務，其中每個訊息都與一個 function 相關聯。</li><li>當堆疊中有足夠空間時，會從Event queue 事件佇列拿取一個任務進行處理，處理過程包含了呼叫相關聯的 function。只有當堆疊清空時，該佇列才算是完成處理。</li></ul><hr><p>上面分別介紹了Call Stack、Web APIs、Event queue，接下來可以將他們組起來了！組起來後可以更好地理解Event Loop。</p><hr><h2 id="Event-Loop-事件循環-4"><a href="#Event-Loop-事件循環-4" class="headerlink" title="Event Loop 事件循環"></a>Event Loop 事件循環</h2><p><img src="/images/eventLoop/eventloop.png"></p><ul><li>Event Loop 它不斷檢查Call Stack呼叫堆疊是否為空。<ul><li>如果為空：則從事件佇列Event queue中新增函式至Call Stack。 </li><li>新增函式至Call Stack的步驟，又稱為非同步回調（asynchronous ）</li><li>如果不為空：處理Call Stack內的函數。</li></ul></li></ul><h2 id="範例示意-3"><a href="#範例示意-3" class="headerlink" title="範例示意"></a>範例示意</h2><p>當然，如果僅以上介紹，無法完整了解，<br>這班準備了幾個程式碼及搭配<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>，讓讀者能夠更了解其運行步驟</p><p>:warning:可以按此<a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coIkhpIik7CnNldFRpbWVvdXQoZnVuY3Rpb24gY2IoKSB7CiAgY29uc29sZS5sb2coInRoZXJlIik7Cn0sIDUwMDApOwpjb25zb2xlLmxvZygiZW5kIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>了解JavaScript運行以上程式的步驟</p><h3 id="範例示範1-3"><a href="#範例示範1-3" class="headerlink" title="範例示範1"></a>範例示範1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;there&quot;</span>);<br>&#125;, <span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi<br><span class="hljs-keyword">end</span><br>there<br></code></pre></td></tr></table></figure><h3 id="範例示範2-3"><a href="#範例示範2-3" class="headerlink" title="範例示範2"></a>範例示範2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><p><img src="/images/eventLoop/pasted-0.png" alt="upload successful"></p><p>此又稱為<strong>堆疊爆炸</strong>，當 Stack 不斷增長，直到瀏覽器內存耗盡。<br>是瀏覽器在哀嚎的聲音😂😂</p><p>以上是關於Event Loop的介紹，是我由以下參考資料整理+自己繪圖而成，如果您有興趣了解更多，請參考：</p><h3 id="參考資料：-3"><a href="#參考資料：-3" class="headerlink" title="參考資料："></a>參考資料：</h3><blockquote><p>What the heck is the event loop anyway? | Philip Roberts<br><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p><p>請說明瀏覽器中的事件循環 (Event Loop)<br><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">https://www.explainthis.io/zh-hant/swe/what-is-event-loop</a></p><p>What is an event loop in JavaScript?<br><a href="https://www.educative.io/answers/what-is-an-event-loop-in-javascript">https://www.educative.io/answers/what-is-an-event-loop-in-javascript</a></p></blockquote><ul><li>Event Loop 它不斷檢查Call Stack呼叫堆疊是否為空。<ul><li>如果為空：則從事件佇列Event queue中新增函式至Call Stack。 </li><li>新增函式至Call Stack的步驟，又稱為非同步回調（asynchronous ）</li><li>如果不為空：處理Call Stack內的函數。</li></ul></li></ul><h2 id="範例示意-4"><a href="#範例示意-4" class="headerlink" title="範例示意"></a>範例示意</h2><p>當然，如果僅以上介紹，無法完整了解，<br>這班準備了幾個程式碼及搭配<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>，讓讀者能夠更了解其運行步驟</p><p>:warning:可以按此<a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coIkhpIik7CnNldFRpbWVvdXQoZnVuY3Rpb24gY2IoKSB7CiAgY29uc29sZS5sb2coInRoZXJlIik7Cn0sIDUwMDApOwpjb25zb2xlLmxvZygiZW5kIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>了解JavaScript運行以上程式的步驟</p><h3 id="範例示範1-4"><a href="#範例示範1-4" class="headerlink" title="範例示範1"></a>範例示範1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;there&quot;</span>);<br>&#125;, <span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi<br><span class="hljs-keyword">end</span><br>there<br></code></pre></td></tr></table></figure><h3 id="範例示範2-4"><a href="#範例示範2-4" class="headerlink" title="範例示範2"></a>範例示範2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><h1 id="JavaScript：究竟什麼是Event-Loop-5"><a href="#JavaScript：究竟什麼是Event-Loop-5" class="headerlink" title="JavaScript：究竟什麼是Event Loop"></a>JavaScript：究竟什麼是Event Loop</h1><p>JavaScript 是單執行緒又稱為單線程（Single Thread）的設計，它一次只能執行一個任務， 而「Event Loop」就是使JavaScript能夠處理多個任務的秘訣💡</p><h2 id="JavaScript-5"><a href="#JavaScript-5" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript包含了：Call Stack（呼叫堆疊）、Event Loop（事件循環）、Callback quequ(回調佇列)，以下會逐步介紹。</p><h2 id="Call-Stack呼叫堆疊-5"><a href="#Call-Stack呼叫堆疊-5" class="headerlink" title="Call Stack呼叫堆疊"></a>Call Stack呼叫堆疊</h2><p><img src="/images/eventLoop/callstack.png"></p><ul><li>因為JavaScript為單執行緒的設計，<strong>一次只能執行一個動作</strong>，因此等待執行的任務會被放入Call Stack。</li><li>準備執行的任務會像積木一樣，由下往上堆疊。</li><li>執行時，也像積木一樣，由上往下拿取，也稱為先進後出法（LIFO, Last in First out）</li></ul><hr><p>但如果出現像SetTimeout()、fetch()等等運行時間較長的函數，該怎麼辦呢？這個時候Web API就派上用場了！</p><hr><h2 id="Web-APIs-5"><a href="#Web-APIs-5" class="headerlink" title="Web APIs"></a>Web APIs</h2><p><img src="/images/eventLoop/webapis.png"></p><ul><li>每當呼叫非同步函數時，它都會被傳送到對應的瀏覽器API，該API會等待完成函數延遲的操作後再傳回進行處理。 </li><li>以setTimeout()為例，當Call Stack執行時，setTimeout()會被傳送到Web API，等待指定的時間完成再將該操作傳回進行處理。</li></ul><hr><p>從Web API等時間跑完後，它將操作發送到哪裡？他們被發送到<strong>事件佇列（Event queue）</strong></p><hr><h2 id="Event-queue-事件佇列-5"><a href="#Event-queue-事件佇列-5" class="headerlink" title="Event queue 事件佇列"></a>Event queue 事件佇列</h2><p><img src="/images/eventLoop/eventque.png"></p><ul><li>Event queue 裡面是待執行的任務，其中每個訊息都與一個 function 相關聯。</li><li>當堆疊中有足夠空間時，會從Event queue 事件佇列拿取一個任務進行處理，處理過程包含了呼叫相關聯的 function。只有當堆疊清空時，該佇列才算是完成處理。</li></ul><hr><p>上面分別介紹了Call Stack、Web APIs、Event queue，接下來可以將他們組起來了！組起來後可以更好地理解Event Loop。</p><hr><h2 id="Event-Loop-事件循環-5"><a href="#Event-Loop-事件循環-5" class="headerlink" title="Event Loop 事件循環"></a>Event Loop 事件循環</h2><p><img src="/images/eventLoop/eventloop.png"></p><ul><li>Event Loop 它不斷檢查Call Stack呼叫堆疊是否為空。<ul><li>如果為空：則從事件佇列Event queue中新增函式至Call Stack。 </li><li>新增函式至Call Stack的步驟，又稱為非同步回調（asynchronous ）</li><li>如果不為空：處理Call Stack內的函數。</li></ul></li></ul><h2 id="範例示意-5"><a href="#範例示意-5" class="headerlink" title="範例示意"></a>範例示意</h2><p>當然，如果僅以上介紹，無法完整了解，<br>這班準備了幾個程式碼及搭配<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>，讓讀者能夠更了解其運行步驟</p><p>:warning:可以按此<a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coIkhpIik7CnNldFRpbWVvdXQoZnVuY3Rpb24gY2IoKSB7CiAgY29uc29sZS5sb2coInRoZXJlIik7Cn0sIDUwMDApOwpjb25zb2xlLmxvZygiZW5kIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">loupe</a>了解JavaScript運行以上程式的步驟</p><h3 id="範例示範1-5"><a href="#範例示範1-5" class="headerlink" title="範例示範1"></a>範例示範1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">cb</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;there&quot;</span>);<br>&#125;, <span class="hljs-number">5000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi<br><span class="hljs-keyword">end</span><br>there<br></code></pre></td></tr></table></figure><h3 id="範例示範2-5"><a href="#範例示範2-5" class="headerlink" title="範例示範2"></a>範例示範2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">foo</span>();<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>會得到以下結果：</p><p><img src="/images/eventLoop/pasted-0.png" alt="upload successful"></p><p>此又稱為<strong>堆疊爆炸</strong>，當 Stack 不斷增長，直到瀏覽器內存耗盡。<br>是瀏覽器在哀嚎的聲音😂😂</p><p>以上是關於Event Loop的介紹，是我由以下參考資料整理+自己繪圖而成，如果您有興趣了解更多，請參考：</p><h3 id="參考資料：-4"><a href="#參考資料：-4" class="headerlink" title="參考資料："></a>參考資料：</h3><blockquote><p>What the heck is the event loop anyway? | Philip Roberts<br><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p><p>請說明瀏覽器中的事件循環 (Event Loop)<br><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">https://www.explainthis.io/zh-hant/swe/what-is-event-loop</a></p><p>What is an event loop in JavaScript?<br><a href="https://www.educative.io/answers/what-is-an-event-loop-in-javascript">https://www.educative.io/answers/what-is-an-event-loop-in-javascript</a></p></blockquote><p>此又稱為<strong>堆疊爆炸</strong>，當 Stack 不斷增長，直到瀏覽器內存耗盡。<br>是瀏覽器在哀嚎的聲音😂😂</p><p>以上是關於Event Loop的介紹，是我由以下參考資料整理+自己繪圖而成，如果您有興趣了解更多，請參考：</p><h3 id="參考資料：-5"><a href="#參考資料：-5" class="headerlink" title="參考資料："></a>參考資料：</h3><blockquote><p>What the heck is the event loop anyway? | Philip Roberts<br><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a></p><p>請說明瀏覽器中的事件循環 (Event Loop)<br><a href="https://www.explainthis.io/zh-hant/swe/what-is-event-loop">https://www.explainthis.io/zh-hant/swe/what-is-event-loop</a></p><p>What is an event loop in JavaScript?<br><a href="https://www.educative.io/answers/what-is-an-event-loop-in-javascript">https://www.educative.io/answers/what-is-an-event-loop-in-javascript</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Event Post</title>
      <link href="/2023/11/03/Event-Post/"/>
      <url>/2023/11/03/Event-Post/</url>
      
        <content type="html"><![CDATA[<h1 id="Event-Post"><a href="#Event-Post" class="headerlink" title="Event Post"></a>Event Post</h1>]]></content>
      
      
      <categories>
          
          <category> Web Development &amp; Internet Technologies </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Event Post </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CORS</title>
      <link href="/2023/11/01/CORS/"/>
      <url>/2023/11/01/CORS/</url>
      
        <content type="html"><![CDATA[<h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><blockquote><p>跨來源資源共用（Cross-Origin Resource Sharing，簡稱CORS）</p></blockquote><p>當利用JavaScript抓取別人資料時可能發生狀況，CORS主要擋瀏覽器內的JS<br>錯誤訊息如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">has been blocked by <span class="hljs-variable constant_">CORS</span> policy<br></code></pre></td></tr></table></figure><h2 id="如何解決CORS"><a href="#如何解決CORS" class="headerlink" title="如何解決CORS?"></a>如何解決CORS?</h2><ul><li>和對方說請對方開</li><li>自己寫一個API網站，API網站透過後端去抓資料，再抓自己寫的API<br>雖然這樣比較麻煩，但因為CORS只擋瀏覽器裡的JS，如果是用Node js,Ruby,Python等其他程式語言，透過後端去抓資料的話，基本上不會被CORS擋下</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
